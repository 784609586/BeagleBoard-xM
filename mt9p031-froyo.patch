diff -Naur kernel/arch/arm/mach-omap2/board-omap3beagle.c kernel.tmp/arch/arm/mach-omap2/board-omap3beagle.c
--- kernel/arch/arm/mach-omap2/board-omap3beagle.c	2011-04-12 15:28:39.478707932 -0700
+++ kernel.tmp/arch/arm/mach-omap2/board-omap3beagle.c	2011-04-15 13:08:47.223208376 -0700
@@ -82,6 +82,12 @@
 extern struct mt9t112_platform_data mt9t112_pdata;
 #endif
 
+#if defined(CONFIG_VIDEO_MT9P031) || defined(CONFIG_VIDEO_MT9P031_MODULE)
+#include <media/v4l2-int-device.h>
+#include <media/mt9p031.h>
+extern struct mt9p031_platform_data mt9p031_pdata;
+#endif
+
 #define GPMC_CS0_BASE  0x60
 #define GPMC_CS_SIZE   0x30
 
@@ -97,7 +103,7 @@
 
 #define GOOGLE_VENDOR_ID		0x18d1
 #define GOOGLE_PRODUCT_ID		0x9018
-#define GOOGLE_ADB_PRODUCT_ID		0x9015
+#define GOOGLE_ADB_PRODUCT_ID	0x9015
 
 static char *usb_functions_adb[] = {
 	"adb",
@@ -668,8 +674,15 @@
 		.platform_data	= &mt9t112_pdata,
 	},
 #endif
+#if defined(CONFIG_VIDEO_MT9P031) || defined(CONFIG_VIDEO_MT9P031_MODULE)
+	{
+		I2C_BOARD_INFO("mt9p031", MT9P031_I2C_ADDR),
+		.platform_data	= &mt9p031_pdata,
+	},
+#endif
 };
 
+
 static int __init omap3_beagle_i2c_init(void)
 {
 	omap_register_i2c_bus(1, 2600, beagle_i2c1_boardinfo,
diff -Naur kernel/arch/arm/mach-omap2/board-omap3beagle-camera.c kernel.tmp/arch/arm/mach-omap2/board-omap3beagle-camera.c
--- kernel/arch/arm/mach-omap2/board-omap3beagle-camera.c	2011-04-12 15:28:39.478707932 -0700
+++ kernel.tmp/arch/arm/mach-omap2/board-omap3beagle-camera.c	2011-04-15 13:08:47.223208376 -0700
@@ -44,6 +44,14 @@
 
 #include "mux.h"
 
+#define DEBUG_CAM_BOARD_PRINT  1
+#ifdef  DEBUG_CAM_BOARD_PRINT
+#define DPRINTK_CAM_BOARD(format, ...)				\
+	printk(KERN_INFO "_BEAGLE_CAM: " format, ## __VA_ARGS__)
+#else
+#define DPRINTK_CAM_BOARD(format, ...)
+#endif
+
 #define CAM_USE_XCLKA		0
 
 #define LEOPARD_RESET_GPIO	98
@@ -368,8 +376,193 @@
 
 #endif				/* #ifdef CONFIG_VIDEO_MT9T112 */
 
+#if defined(CONFIG_VIDEO_MT9P031) || defined(CONFIG_VIDEO_MT9P031_MODULE)
+#include <media/mt9p031.h>
+
+#define ISP_MT9P031_MCLK	216000000
+
+/* Arbitrary memory handling limit */
+#define MT9P031_BIGGEST_FRAME_BYTE_SIZE	PAGE_ALIGN((2048 * 2) * 1536 * 4)
+
+static struct isp_interface_config mt9p031_if_config = {
+	.ccdc_par_ser		= ISP_PARLL,
+	.dataline_shift		= 0x1,
+	.hsvs_syncdetect	= ISPCTRL_SYNC_DETECT_VSRISE,
+	.strobe			= 0x0,
+	.prestrobe		= 0x0,
+	.shutter		= 0x0,
+	.cam_mclk		= ISP_MT9P031_MCLK,
+	.wenlog 		= ISPCCDC_CFG_WENLOG_AND,
+	.wait_hs_vs		= 2,
+	.u.par.par_bridge	= 0x0,
+	.u.par.par_clk_pol	= 0x0,
+};
+
+static struct v4l2_ifparm mt9p031_ifparm_s = {
+	.if_type = V4L2_IF_TYPE_RAW,
+	.u 	 = {
+		.raw = {
+			.frame_start_on_rising_vs = 1,
+			.bt_sync_correct	= 0,
+			.swap			= 0,
+			.latch_clk_inv		= 0,
+			.nobt_hs_inv		= 0,	/* active high */
+			.nobt_vs_inv		= 0,	/* active high */
+			.clock_min		= MT9P031_CLK_MIN,
+			.clock_max		= MT9P031_CLK_MAX,
+		},
+	},
+};
+
+/**
+ * @brief mt9p031_ifparm - Returns the mt9p031 interface parameters
+ *
+ * @param p - pointer to v4l2_ifparm structure
+ *
+ * @return result of operation - 0 is success
+ */
+static int mt9p031_ifparm(struct v4l2_ifparm *p)
+{
+	if (p == NULL)
+		return -EINVAL;
+
+	*p = mt9p031_ifparm_s;
+	return 0;
+}
+
+#if defined(CONFIG_VIDEO_OMAP3) || defined(CONFIG_VIDEO_OMAP3_MODULE)
+static struct omap34xxcam_hw_config mt9p031_hwc = {
+	.dev_index		= 1,
+	.dev_minor		= -1,
+	.dev_type		= OMAP34XXCAM_SLAVE_SENSOR,
+	.u.sensor.sensor_isp	= 0,
+	.u.sensor.capture_mem	= MT9P031_BIGGEST_FRAME_BYTE_SIZE,
+	.u.sensor.ival_default	= { 1, 30 },
+};
+#endif
+
+/**
+ * @brief mt9p031_set_prv_data - Returns mt9p031 omap34xx driver private data
+ *
+ * @param priv - pointer to omap34xxcam_hw_config structure
+ *
+ * @return result of operation - 0 is success
+ */
+static int mt9p031_set_prv_data(void *priv)
+{
+#if defined(CONFIG_VIDEO_OMAP3) || defined(CONFIG_VIDEO_OMAP3_MODULE)
+	struct omap34xxcam_hw_config *hwc = priv;
+
+	if (priv == NULL)
+		return -EINVAL;
+
+	DPRINTK_CAM_BOARD("===board-omap3beagle-camera.c::mt9p031_set_prv_data() got called\n");
+	*hwc = mt9p031_hwc;
+	return 0;
+#else
+	DPRINTK_CAM_BOARD("===board-omap3beagle-camera.c::mt9p031_set_prv_data() got missed\n");
+	return -EINVAL;
+#endif
+}
+
+/**
+ * @brief mt9p031_power_set - Power-on or power-off mt9p031 device
+ *
+ * @param power - enum, Power on/off, resume/standby
+ *
+ * @return result of operation - 0 is success
+ */
+static int mt9p031_power_set(struct v4l2_int_device *s, enum v4l2_power power)
+{	
+	struct omap34xxcam_videodev *vdev = s->u.slave->master->priv;
+	DPRINTK_CAM_BOARD("===board-omap3beagle-camera.c::mt9p031_power_set() got called\n");
+
+	switch (power) {
+	case V4L2_POWER_OFF:
+		DPRINTK_CAM_BOARD("-->board-omap3beagle-camera.c::mt9p031_power_set()-->V4L2_POWER_OFF got called\n");
+		break;
+	case V4L2_POWER_STANDBY:
+		DPRINTK_CAM_BOARD("-->board-omap3beagle-camera.c::mt9p031_power_set()-->V4L2_POWER_STANDBY got called\n");
+		isp_set_xclk(vdev->cam->isp, 0, CAM_USE_XCLKA);
+
+		if (regulator_is_enabled(cam_1v8_reg))
+			regulator_disable(cam_1v8_reg);
+		if (regulator_is_enabled(cam_2v8_reg))
+			regulator_disable(cam_2v8_reg);
+		break;
+
+	case V4L2_POWER_ON:
+#if defined(CONFIG_VIDEO_OMAP3) || defined(CONFIG_VIDEO_OMAP3_MODULE)
+		DPRINTK_CAM_BOARD("-->board-omap3beagle-camera.c::mt9p031_power_set()-->V4L2_POWER_ON got called\n");
+		isp_configure_interface(vdev->cam->isp, &mt9p031_if_config);
+#endif
+
+		/* Set RESET_BAR to 0 */
+		gpio_set_value(LEOPARD_RESET_GPIO, 0);
+
+		/* turn on VDD */
+		regulator_enable(cam_1v8_reg);
+
+		mdelay(1);
+
+		/* turn on VDD_IO */
+		regulator_enable(cam_2v8_reg);
+
+		mdelay(50);
+
+		/* Enable EXTCLK */
+		isp_set_xclk(vdev->cam->isp, 24000000, CAM_USE_XCLKA);  //works for 36MHz too; try at lower freq
+
+		/*
+		 * Wait at least 70 CLK cycles (w/EXTCLK = 24MHz):
+		 * ((1000000 * 70) / 24000000) = aprox 2.91 us.
+		 */
+
+		udelay(3);
+
+		/* Set RESET_BAR to 1 */
+		gpio_set_value(LEOPARD_RESET_GPIO, 1);
+
+		/*
+		 * Wait at least 100 CLK cycles (w/EXTCLK = 24MHz):
+		 * ((1000000 * 100) / 24000000) = aprox 4.16 us.
+		 */
+
+		udelay(5);
+
+		break;
+
+	default:
+		printk(KERN_INFO "===board-omap3beagle-camera.c::mt9p031_power_set() failed\n");
+		return -ENODEV;
+		break;
+	}
+	DPRINTK_CAM_BOARD("===board-omap3beagle-camera.c::mt9p031_power_set() completed\n");
+	return 0;
+}
+
+static u32 mt9p031_set_xclk(struct v4l2_int_device *s, u32 xclkfreq)
+{
+    struct omap34xxcam_videodev *vdev = s->u.slave->master->priv;
+	DPRINTK_CAM_BOARD("===board-omap3beagle-camera.c::mt9p031_set_xclk() got called\n");
+    return isp_set_xclk(vdev->cam->isp, xclkfreq, 0);
+}
+
+
+struct mt9p031_platform_data mt9p031_pdata = {
+	.master		= "omap34xxcam",
+	.power_set	= mt9p031_power_set,
+	.set_xclk       = mt9p031_set_xclk,
+	.priv_data_set	= mt9p031_set_prv_data,
+	.ifparm		= mt9p031_ifparm,
+};
+
+#endif				/* #ifdef CONFIG_VIDEO_MT9P031 */
+
 static int beagle_cam_probe(struct platform_device *pdev)
 {
+	DPRINTK_CAM_BOARD("===board-omap3beagle-camera.c::beagle_cam_probe() got called\n");
+
 	cam_1v8_reg = regulator_get(&pdev->dev, "cam_1v8");
 	if (IS_ERR(cam_1v8_reg)) {
 		dev_err(&pdev->dev, "cam_1v8 regulator missing\n");
@@ -395,40 +588,24 @@
 	gpio_direction_output(LEOPARD_RESET_GPIO, 0);
 
 	/* MUX init */
-	omap_ctrl_writew(OMAP_PIN_INPUT_PULLUP | OMAP_MUX_MODE0,
-			 0x10C); /* CAM_HS */
-	omap_ctrl_writew(OMAP_PIN_INPUT_PULLUP | OMAP_MUX_MODE0,
-			 0x10E); /* CAM_VS */
-	omap_ctrl_writew(OMAP_PIN_OUTPUT | OMAP_MUX_MODE0,
-			 0x110); /* CAM_XCLKA */
-	omap_ctrl_writew(OMAP_PIN_INPUT_PULLUP | OMAP_MUX_MODE0,
-			 0x112); /* CAM_PCLK */
-	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0,
-			 0x116); /* CAM_D0 */
-	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0,
-			 0x118); /* CAM_D1 */
-	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0,
-			 0x11A); /* CAM_D2 */
-	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0,
-			 0x11C); /* CAM_D3 */
-	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0,
-			 0x11E); /* CAM_D4 */
-	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0,
-			 0x120); /* CAM_D5 */
-	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0,
-			 0x122); /* CAM_D6 */
-	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0,
-			 0x124); /* CAM_D7 */
-	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0,
-			 0x126); /* CAM_D8 */
-	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0,
-			 0x128); /* CAM_D9 */
-	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0,
-			 0x12A); /* CAM_D10 */
-	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0,
-			 0x12C); /* CAM_D11 */
+	omap_ctrl_writew(OMAP_PIN_INPUT_PULLUP | OMAP_MUX_MODE0, 0x10C); /* CAM_HS */
+	omap_ctrl_writew(OMAP_PIN_INPUT_PULLUP | OMAP_MUX_MODE0, 0x10E); /* CAM_VS */
+	omap_ctrl_writew(OMAP_PIN_OUTPUT | OMAP_MUX_MODE0, 0x110); /* CAM_XCLKA */
+	omap_ctrl_writew(OMAP_PIN_INPUT_PULLUP | OMAP_MUX_MODE0, 0x112); /* CAM_PCLK */
+	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0, 0x116); /* CAM_D0 */
+	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0, 0x118); /* CAM_D1 */
+	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0, 0x11A); /* CAM_D2 */
+	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0, 0x11C); /* CAM_D3 */
+	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0, 0x11E); /* CAM_D4 */
+	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0, 0x120); /* CAM_D5 */
+	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0, 0x122); /* CAM_D6 */
+	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0, 0x124); /* CAM_D7 */
+	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0, 0x126); /* CAM_D8 */
+	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0, 0x128); /* CAM_D9 */
+	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0, 0x12A); /* CAM_D10 */
+	omap_ctrl_writew(OMAP_PIN_INPUT | OMAP_MUX_MODE0, 0x12C); /* CAM_D11 */
 
-	printk(KERN_INFO "omap3beaglelmb: Driver registration complete\n");
+	DPRINTK_CAM_BOARD("===board-omap3beagle-camera.c: beagle_cam_probe() complete\n");
 
 	return 0;
 }
@@ -444,6 +621,7 @@
 	regulator_put(cam_2v8_reg);
 
 	gpio_free(LEOPARD_RESET_GPIO);
+	DPRINTK_CAM_BOARD("===board-omap3beagle-camera.c: Driver remove complete\n");
 
 	return 0;
 }
@@ -480,9 +658,13 @@
  */
 int __init omap3beaglelmb_init(void)
 {
+	DPRINTK_CAM_BOARD("board-omap3beagle-camera.c::omap3beaglelmb_init() got called\n");
+
 	/* NOTE: Beagle xM boards are the only ones with camera interface */
-	if (cpu_is_omap3630())
+	if (cpu_is_omap3630()) {
+		DPRINTK_CAM_BOARD("board-omap3beagle-camera.c::omap3beaglelmb_init()-->cpu_is_omap3630()\n");
 		platform_driver_register(&beagle_cam_driver);
+	}
 
 	return 0;
 }
diff -Naur kernel/arch/arm/mach-omap2/v4l2-chip-ident.h kernel.tmp/arch/arm/mach-omap2/v4l2-chip-ident.h
--- kernel/arch/arm/mach-omap2/v4l2-chip-ident.h	1969-12-31 16:00:00.000000000 -0800
+++ kernel.tmp/arch/arm/mach-omap2/v4l2-chip-ident.h	2011-04-15 13:09:59.143011515 -0700
@@ -0,0 +1,295 @@
+/*
+    v4l2 chip identifiers header
+
+    This header provides a list of chip identifiers that can be returned
+    through the VIDIOC_DBG_G_CHIP_IDENT ioctl.
+
+    Copyright (C) 2007 Hans Verkuil <hverkuil@xs4all.nl>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef V4L2_CHIP_IDENT_H_
+#define V4L2_CHIP_IDENT_H_
+
+/* VIDIOC_DBG_G_CHIP_IDENT: identifies the actual chip installed on the board */
+enum {
+	/* general idents: reserved range 0-49 */
+	V4L2_IDENT_NONE      = 0,       /* No chip matched */
+	V4L2_IDENT_AMBIGUOUS = 1,       /* Match too general, multiple chips matched */
+	V4L2_IDENT_UNKNOWN   = 2,       /* Chip found, but cannot identify */
+
+	/* module tvaudio: reserved range 50-99 */
+	V4L2_IDENT_TVAUDIO = 50,	/* A tvaudio chip, unknown which it is exactly */
+
+	/* module saa7110: just ident 100 */
+	V4L2_IDENT_SAA7110 = 100,
+
+	/* module saa7115: reserved range 101-149 */
+	V4L2_IDENT_SAA7111 = 101,
+	V4L2_IDENT_SAA7113 = 103,
+	V4L2_IDENT_SAA7114 = 104,
+	V4L2_IDENT_SAA7115 = 105,
+	V4L2_IDENT_SAA7118 = 108,
+
+	/* module saa7127: reserved range 150-199 */
+	V4L2_IDENT_SAA7127 = 157,
+	V4L2_IDENT_SAA7129 = 159,
+
+	/* module cx25840: reserved range 200-249 */
+	V4L2_IDENT_CX25836 = 236,
+	V4L2_IDENT_CX25837 = 237,
+	V4L2_IDENT_CX25840 = 240,
+	V4L2_IDENT_CX25841 = 241,
+	V4L2_IDENT_CX25842 = 242,
+	V4L2_IDENT_CX25843 = 243,
+
+	/* OmniVision sensors: reserved range 250-299 */
+	V4L2_IDENT_OV7670 = 250,
+	V4L2_IDENT_OV7720 = 251,
+	V4L2_IDENT_OV7725 = 252,
+	V4L2_IDENT_OV7660 = 253,
+	V4L2_IDENT_OV9650 = 254,
+	V4L2_IDENT_OV9655 = 255,
+	V4L2_IDENT_SOI968 = 256,
+	V4L2_IDENT_OV9640 = 257,
+
+	/* module saa7146: reserved range 300-309 */
+	V4L2_IDENT_SAA7146 = 300,
+
+	/* Conexant MPEG encoder/decoders: reserved range 400-420 */
+	V4L2_IDENT_CX23418_843 = 403, /* Integrated A/V Decoder on the '418 */
+	V4L2_IDENT_CX23415 = 415,
+	V4L2_IDENT_CX23416 = 416,
+	V4L2_IDENT_CX23417 = 417,
+	V4L2_IDENT_CX23418 = 418,
+
+	/* module au0828 */
+	V4L2_IDENT_AU0828 = 828,
+
+	/* module indycam: just ident 2000 */
+	V4L2_IDENT_INDYCAM = 2000,
+
+	/* module bt819: reserved range 810-819 */
+	V4L2_IDENT_BT815A = 815,
+	V4L2_IDENT_BT817A = 817,
+	V4L2_IDENT_BT819A = 819,
+
+	/* module bt856: just ident 856 */
+	V4L2_IDENT_BT856 = 856,
+
+	/* module bt866: just ident 866 */
+	V4L2_IDENT_BT866 = 866,
+
+	/* module ks0127: reserved range 1120-1129 */
+	V4L2_IDENT_KS0122S = 1122,
+	V4L2_IDENT_KS0127  = 1127,
+	V4L2_IDENT_KS0127B = 1128,
+
+	/* module vp27smpx: just ident 2700 */
+	V4L2_IDENT_VP27SMPX = 2700,
+
+	/* module vpx3220: reserved range: 3210-3229 */
+	V4L2_IDENT_VPX3214C = 3214,
+	V4L2_IDENT_VPX3216B = 3216,
+	V4L2_IDENT_VPX3220A = 3220,
+
+	/* module tvp5150 */
+	V4L2_IDENT_TVP5150 = 5150,
+
+	/* module saa5246a: just ident 5246 */
+	V4L2_IDENT_SAA5246A = 5246,
+
+	/* module saa5249: just ident 5249 */
+	V4L2_IDENT_SAA5249 = 5249,
+
+	/* module cs5345: just ident 5345 */
+	V4L2_IDENT_CS5345 = 5345,
+
+	/* module tea6415c: just ident 6415 */
+	V4L2_IDENT_TEA6415C = 6415,
+
+	/* module tea6420: just ident 6420 */
+	V4L2_IDENT_TEA6420 = 6420,
+
+	/* module saa6588: just ident 6588 */
+	V4L2_IDENT_SAA6588 = 6588,
+
+	/* module saa6752hs: reserved range 6750-6759 */
+	V4L2_IDENT_SAA6752HS = 6752,
+	V4L2_IDENT_SAA6752HS_AC3 = 6753,
+
+	/* modules tef6862: just ident 6862 */
+	V4L2_IDENT_TEF6862 = 6862,
+
+	/* module adv7170: just ident 7170 */
+	V4L2_IDENT_ADV7170 = 7170,
+
+	/* module adv7175: just ident 7175 */
+	V4L2_IDENT_ADV7175 = 7175,
+
+	/* module adv7180: just ident 7180 */
+	V4L2_IDENT_ADV7180 = 7180,
+
+	/* module saa7185: just ident 7185 */
+	V4L2_IDENT_SAA7185 = 7185,
+
+	/* module saa7191: just ident 7191 */
+	V4L2_IDENT_SAA7191 = 7191,
+
+	/* module ths7303: just ident 7303 */
+	V4L2_IDENT_THS7303 = 7303,
+
+	/* module adv7343: just ident 7343 */
+	V4L2_IDENT_ADV7343 = 7343,
+
+	/* module wm8739: just ident 8739 */
+	V4L2_IDENT_WM8739 = 8739,
+
+	/* module wm8775: just ident 8775 */
+	V4L2_IDENT_WM8775 = 8775,
+
+	/* module tda9840: just ident 9840 */
+	V4L2_IDENT_TDA9840 = 9840,
+
+	/* module cafe_ccic, just ident 8801 */
+	V4L2_IDENT_CAFE = 8801,
+
+	/* module mt9v011, just ident 8243 */
+	V4L2_IDENT_MT9V011 = 8243,
+
+	/* module cx23885 and cx25840 */
+	V4L2_IDENT_CX23885    = 8850,
+	V4L2_IDENT_CX23885_AV = 8851, /* Integrated A/V decoder */
+	V4L2_IDENT_CX23887    = 8870,
+	V4L2_IDENT_CX23887_AV = 8871, /* Integrated A/V decoder */
+	V4L2_IDENT_CX23888    = 8880,
+	V4L2_IDENT_CX23888_AV = 8881, /* Integrated A/V decoder */
+	V4L2_IDENT_CX23888_IR = 8882, /* Integrated infrared controller */
+
+	/* module tw9910: just ident 9910 */
+	V4L2_IDENT_TW9910 = 9910,
+
+	/* module sn9c20x: just ident 10000 */
+	V4L2_IDENT_SN9C20X = 10000,
+
+	/* module cx231xx and cx25840 */
+	V4L2_IDENT_CX2310X_AV = 23099, /* Integrated A/V decoder; not in '100 */
+	V4L2_IDENT_CX23100    = 23100,
+	V4L2_IDENT_CX23101    = 23101,
+	V4L2_IDENT_CX23102    = 23102,
+
+	/* module msp3400: reserved range 34000-34999 and 44000-44999 */
+	V4L2_IDENT_MSPX4XX  = 34000, /* generic MSPX4XX identifier, only
+					use internally (tveeprom.c). */
+
+	V4L2_IDENT_MSP3400B = 34002,
+	V4L2_IDENT_MSP3410B = 34102,
+
+	V4L2_IDENT_MSP3400C = 34003,
+	V4L2_IDENT_MSP3410C = 34103,
+
+	V4L2_IDENT_MSP3400D = 34004,
+	V4L2_IDENT_MSP3410D = 34104,
+	V4L2_IDENT_MSP3405D = 34054,
+	V4L2_IDENT_MSP3415D = 34154,
+	V4L2_IDENT_MSP3407D = 34074,
+	V4L2_IDENT_MSP3417D = 34174,
+
+	V4L2_IDENT_MSP3400G = 34007,
+	V4L2_IDENT_MSP3410G = 34107,
+	V4L2_IDENT_MSP3420G = 34207,
+	V4L2_IDENT_MSP3430G = 34307,
+	V4L2_IDENT_MSP3440G = 34407,
+	V4L2_IDENT_MSP3450G = 34507,
+	V4L2_IDENT_MSP3460G = 34607,
+
+	V4L2_IDENT_MSP3401G = 34017,
+	V4L2_IDENT_MSP3411G = 34117,
+	V4L2_IDENT_MSP3421G = 34217,
+	V4L2_IDENT_MSP3431G = 34317,
+	V4L2_IDENT_MSP3441G = 34417,
+	V4L2_IDENT_MSP3451G = 34517,
+	V4L2_IDENT_MSP3461G = 34617,
+
+	V4L2_IDENT_MSP3402G = 34027,
+	V4L2_IDENT_MSP3412G = 34127,
+	V4L2_IDENT_MSP3422G = 34227,
+	V4L2_IDENT_MSP3442G = 34427,
+	V4L2_IDENT_MSP3452G = 34527,
+
+	V4L2_IDENT_MSP3405G = 34057,
+	V4L2_IDENT_MSP3415G = 34157,
+	V4L2_IDENT_MSP3425G = 34257,
+	V4L2_IDENT_MSP3435G = 34357,
+	V4L2_IDENT_MSP3445G = 34457,
+	V4L2_IDENT_MSP3455G = 34557,
+	V4L2_IDENT_MSP3465G = 34657,
+
+	V4L2_IDENT_MSP3407G = 34077,
+	V4L2_IDENT_MSP3417G = 34177,
+	V4L2_IDENT_MSP3427G = 34277,
+	V4L2_IDENT_MSP3437G = 34377,
+	V4L2_IDENT_MSP3447G = 34477,
+	V4L2_IDENT_MSP3457G = 34577,
+	V4L2_IDENT_MSP3467G = 34677,
+
+	/* module msp3400: reserved range 34000-34999 and 44000-44999 */
+	V4L2_IDENT_MSP4400G = 44007,
+	V4L2_IDENT_MSP4410G = 44107,
+	V4L2_IDENT_MSP4420G = 44207,
+	V4L2_IDENT_MSP4440G = 44407,
+	V4L2_IDENT_MSP4450G = 44507,
+
+	V4L2_IDENT_MSP4408G = 44087,
+	V4L2_IDENT_MSP4418G = 44187,
+	V4L2_IDENT_MSP4428G = 44287,
+	V4L2_IDENT_MSP4448G = 44487,
+	V4L2_IDENT_MSP4458G = 44587,
+
+	/* Micron CMOS sensor chips: 45000-45099 */
+	V4L2_IDENT_MT9M001C12ST		= 45000,
+	V4L2_IDENT_MT9M001C12STM	= 45005,
+	V4L2_IDENT_MT9M111		= 45007,
+	V4L2_IDENT_MT9M112		= 45008,
+	V4L2_IDENT_MT9V022IX7ATC	= 45010, /* No way to detect "normal" I77ATx */
+	V4L2_IDENT_MT9V022IX7ATM	= 45015, /* and "lead free" IA7ATx chips */
+	V4L2_IDENT_MT9T031		= 45020,
+	V4L2_IDENT_MT9T111		= 45021,
+	V4L2_IDENT_MT9T112		= 45022,
+	V4L2_IDENT_MT9V111		= 45031,
+	V4L2_IDENT_MT9V112		= 45032,
+	V4L2_IDENT_MT9P031		= 6145,
+
+	/* HV7131R CMOS sensor: just ident 46000 */
+	V4L2_IDENT_HV7131R		= 46000,
+
+	/* module cs53132a: just ident 53132 */
+	V4L2_IDENT_CS53l32A = 53132,
+
+	/* module upd64031a: just ident 64031 */
+	V4L2_IDENT_UPD64031A = 64031,
+
+	/* module upd64083: just ident 64083 */
+	V4L2_IDENT_UPD64083 = 64083,
+
+	/* module m52790: just ident 52790 */
+	V4L2_IDENT_M52790 = 52790,
+
+	/* Sharp RJ54N1CB0C, 0xCB0C = 51980 */
+	V4L2_IDENT_RJ54N1CB0C = 51980,
+};
+
+#endif
diff -Naur kernel/drivers/media/video/mt9p031.c kernel.tmp/drivers/media/video/mt9p031.c
--- kernel/drivers/media/video/mt9p031.c	1969-12-31 16:00:00.000000000 -0800
+++ kernel.tmp/drivers/media/video/mt9p031.c	2011-04-15 13:09:40.002457552 -0700
@@ -0,0 +1,1513 @@
+/*
+ * drivers/media/video/mt9p031.c
+ *
+ * Aptina mt9p031 sensor driver
+ *
+ *
+ * Copyright (C) 2010 Aptina Imaging
+ * 
+ * 
+ * Leverage mt9p012.c
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+/*
+ * TODO: 
+ * Verify Preview and Capture for various resolutions[verified for VGA  SIZE only]
+*/
+
+
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/videodev2.h>
+#include <linux/sysfs.h>
+
+#include <media/mt9p031.h>
+#include <media/v4l2-int-device.h>
+#include <media/v4l2-chip-ident.h>
+
+#define MT9P031_DEBUG
+
+#ifdef MT9P031_DEBUG
+#define DPRINTK_DRIVER(format, ...)				\
+	printk(KERN_INFO "_MT9P031_DRIVER: " format, ## __VA_ARGS__)
+#else
+#define DPRINTK_DRIVER(format, ...)
+#endif
+/************************************************************************
+			macro
+************************************************************************/
+// Macro to configure I2c level shifter. Use only for MT9P031 Headboards from Aptina; not required for Leopard Imaging or elsewise. 
+#define MT9P031_HEADBOARD
+
+#define MT9P031_CHIP_ID			0x1801
+#define MT9P031_MAX_HEIGHT		1944
+#define MT9P031_MAX_WIDTH		2592
+#define MT9P031_MIN_HEIGHT		2
+#define MT9P031_MIN_WIDTH		2
+
+#define VGA_HEIGHT		480
+#define VGA_WIDTH		640
+
+#define MT9P031_NORMAL_OPERATION_MODE		(0x1F82) //write
+#define MT9P031_OUTPUT_CTRL_CHIP_UNSELECT	(0x1F80)
+#define MT9P031_OUTPUT_CTRL_HALT		(0x1F83)
+
+/* FPS Capabilities */
+#define MT9P031_MIN_FPS		10
+#define MT9P031_DEF_FPS		30
+#define MT9P031_MAX_FPS		60
+
+#define MT9P031_XCLK_NOM_1 12000000
+#define MT9P031_XCLK_NOM_2 24000000
+
+/* Analog gain values */
+#define MT9P031_EV_MIN_GAIN		0
+#define MT9P031_EV_MAX_GAIN		56
+#define MT9P031_EV_DEF_GAIN		20
+#define MT9P031_EV_GAIN_STEP		1
+
+/* Exposure time values */
+#define MT9P031_MIN_EXPOSURE		15000
+#define MT9P031_MAX_EXPOSURE		128000
+#define MT9P031_DEF_EXPOSURE		33000
+#define MT9P031_EXPOSURE_STEP		100
+#define Q12		4096
+/************************************************************************
+			Register Address
+************************************************************************/
+
+#define REG_MT9P031_CHIP_VERSION		0x00
+#define REG_MT9P031_ROWSTART			0x01
+#define REG_MT9P031_COLSTART			0x02
+#define REG_MT9P031_HEIGHT			0x03
+#define REG_MT9P031_WIDTH			0x04
+#define REG_MT9P031_HBLANK			0x05
+#define REG_MT9P031_VBLANK			0x06
+#define REG_MT9P031_OUT_CTRL			0x07
+#define REG_MT9P031_SHUTTER_WIDTH_U		0x08
+#define REG_MT9P031_SHUTTER_WIDTH_L		0x09
+#define REG_MT9P031_PCLK_CTRL			0x0a
+#define REG_MT9P031_RESTART			0x0b
+#define REG_MT9P031_SHUTTER_DELAY		0x0c
+#define REG_MT9P031_RESET			0x0d
+
+#define REG_MT9P031_PLL_CTRL			0x10
+#define REG_MT9P031_PLL_CONF1			0x11
+#define REG_MT9P031_PLL_CONF2			0x12
+
+#define REG_MT9P031_READ_MODE1			0x1e
+#define REG_MT9P031_READ_MODE2			0x20
+#define REG_MT9P031_ROW_ADDR_MODE		0x22
+#define REG_MT9P031_COL_ADDR_MODE		0x23
+#define REG_MT9P031_GREEN_1_GAIN		0x2b
+#define REG_MT9P031_BLUE_GAIN			0x2c
+#define REG_MT9P031_RED_GAIN			0x2d
+#define REG_MT9P031_GREEN_2_GAIN		0x2e
+#define REG_MT9P031_GLOBAL_GAIN			0x35
+#define REG_MT9P031_CHIP_VERSION_ALT	        0x0FF
+
+/************************************************************************
+			struct
+************************************************************************/
+struct mt9p031_frame_size {
+	u16 width;
+	u16 height;
+};
+
+struct mt9p031_priv {
+	struct mt9p031_platform_data  *pdata;
+	struct v4l2_int_device  *v4l2_int_device;
+	struct i2c_client  *client;
+	struct v4l2_pix_format  pix;
+	struct v4l2_fract timeperframe;
+	unsigned long xclk_current;
+	int fps;
+	int scaler;
+	int ver;
+	int  model;
+	u32  flags;
+/* for flags */
+#define INIT_DONE  (1<<0)
+};
+
+struct mt9p031_priv sysPriv;
+
+static const struct v4l2_fmtdesc mt9p031_formats[] = {
+	{
+		.description = "Bayer (sRGB) 10 bit",
+		.pixelformat = V4L2_PIX_FMT_SRGGB10,
+	},
+};
+
+static const unsigned int mt9p031_num_formats = ARRAY_SIZE(mt9p031_formats);
+
+/***********************Minimum Horizontal blanking*********************/
+int hb_min[4][4] = { 
+    { 450, 430, 0, 420 },
+    { 796, 776, 0, 766 },
+    { 0, 0, 0, 0 },
+    { 1488, 1468, 0, 1458 }, 
+};
+
+/**************************supported sizes******************************/
+const static struct mt9p031_frame_size mt9p031_sizes[] = {
+	{  640, 480 },
+	{ 1280, 720 },
+	{ 1920, 1080 },
+	{ 2048, 1536 },	//3MP
+	{ 2592, 1944 },	//5MP
+};
+
+
+struct mt9p031_format_params {
+	int width;
+	int height;
+	int row_start;
+	int col_start;
+	int row_size;
+	int col_size;
+	int hblank;
+	int vblank;
+	int integ_time;
+	int row_addr_mode;
+	int col_addr_mode;
+	int read_mode_2_config;
+	int shutter_width_hi;
+	int shutter_delay;
+	int row_bin;
+	int col_bin;		
+};
+
+enum mt9p031_image_size {
+	VGA_BIN_30FPS,
+	HDV_720P_30FPS,
+	//HDV_720P_60FPS,
+	//HDV_720P_60FPS_LVB,
+	HDV_1080P_30FPS,
+	MT9P031_THREE_MP,
+	MT9P031_FIVE_MP,
+};
+
+enum mt9p031_image_size mt9p031_current_format;
+
+const struct mt9p031_format_params mt9p031_supported_formats[] = {
+		{ 640, 480, 0x0040, 0x0080, 0x0778, 0x09F8, 0, 0, 0x0296,  0x0033, 0x0033, 0x0060, 0, 0, 3, 3 },  // VGA_BIN_30FPS
+		{ 1280, 720, 0x0040, 0x0018, 0x059F, 0x09FF, 0, 0, 0x0296, 0x0011, 0x0011, 0x0060, 0, 0, 1, 1 },  // 720P_HD_30FPS
+		//{ 1280, 720, 0x0040, 0x0018, 0x059F, 0x09FF, 0, 0, 0x0296, 0x0011, 0x0011, 0x0060, 0, 0, 1, 1 },  // 720P_HD_60FPS
+		//{ 1280, 720, 0x0040, 0x0018, 0x059F, 0x09FF, 0, 0x02D0, 0x0296, 0x0011, 0x0011, 0x0060, 0, 0, 1, 1 },  // 720P_HD_60FPS_LVB
+		{ 1920, 1080, 431, 335, 1079, 1919, 0, 0x0037, 0x01AC, 0, 0, 0x0040, 0, 0, 0, 0 },	// 1080P_30FPS
+		{ 2048, 1536, 431, 335, 1535, 2047, 0, 0x0037, 0x01AC, 0, 0, 0x0040, 0, 0, 0, 0 },	// 3MP CAPTURE		
+		{ 2592, 1944, 431, 335, 1943, 2591, 0, 0x0037, 0x01AC, 0, 0, 0x0040, 0, 0, 0, 0 },	// 5MP CAPTURE	
+};
+
+
+const struct v4l2_fract mt9p031_frameintervals[] = {
+	{ .numerator = 1, .denominator = 10 },
+	{ .numerator = 1, .denominator = 20 },
+	{ .numerator = 1, .denominator = 30 },	
+	{ .numerator = 1, .denominator = 40 },	
+	{ .numerator = 1, .denominator = 50 },		
+};
+
+
+const u16 MT9P031_EV_GAIN_TBL[57] = {
+	/* Gain x1 */
+	8, 9, 10, 11, 12, 13, 14, 15, 
+	/* Gain x2 */
+	16, 17, 18, 19, 20, 21, 22, 23,
+	/* Gain x3 */
+	24, 25, 26, 27, 28, 29, 30, 31, 
+	/* Gain x4 */
+	32, 33, 34, 35, 72, 73, 74, 75,
+	/* Gain x5 */
+	76, 77, 78, 79, 80, 81, 82, 83,
+	/* Gain x6 */
+	84, 85, 86, 87, 88, 89, 90, 91,
+	/* Gain x7 */
+	92, 93, 94, 95, 96, 97, 98, 99,
+	/* Gain x8 */
+	100,
+};
+
+#ifdef MT9P031_HEADBOARD
+/**
+ * mt9p031_config_PCA9543A - configure on-board I2c level-shifter PCA9543A of MT9P031 Headboards from Aptina
+ * @client: pointer to i2c client
+ * Configures the level shifter to enable channel 0 
+ */
+static int mt9p031_config_PCA9543A(const struct i2c_client *client)
+{
+	struct i2c_msg msg;
+	int ret;
+	u8 buf;
+	buf = 0x21;
+	
+	msg.addr  = (0xE6 >> 1);	//slave address of PCA9543A
+	msg.flags = 0;
+	msg.len   = 1;
+	msg.buf   = &buf;
+	
+	ret = i2c_transfer(client->adapter, &msg, 1);
+
+	return 0;
+		
+}
+#endif		//MT9P031_HEADBOARD
+
+/**
+ * mt9p031_reg_read - read resgiter value
+ * @client: pointer to i2c client
+ * @command: register address
+ */
+static int mt9p031_reg_read(const struct i2c_client *client, u16 command, u16 *val)
+{
+	struct i2c_msg msg[2];
+	u8 buf[2];
+	int ret;
+
+	// 8-bit/ byte addressable register
+	buf[0] = command & 0xff;
+
+	msg[0].addr  = client->addr;
+	msg[0].flags = 0;
+	msg[0].len   = 1;
+	msg[0].buf   = buf ;
+	ret = i2c_transfer(client->adapter, &msg[0], 1);
+	
+	if(ret >= 0) {
+		msg[1].addr  = client->addr;
+		msg[1].flags = I2C_M_RD; //1
+		msg[1].len   = 2;
+		msg[1].buf   = buf;
+		ret = i2c_transfer(client->adapter, &msg[1], 1);
+	}
+	/*
+	 * if return value of this function is < 0,
+	 * it mean error.
+	 * else, under 16bit is valid data.
+	 */
+	if(ret >= 0) {
+		*val = 0;
+		*val = buf[1] + (buf[0] << 8);
+		return 0;
+	}
+	
+	v4l_err(client, "read from offset 0x%x error %d", command, ret);
+	return ret;
+}
+
+/**
+ * mt9p031_reg_write - read resgiter value
+ * @client: pointer to i2c client
+ * @command: register address
+ * @data: value to be written 
+ */ 
+static int mt9p031_reg_write(const struct i2c_client *client,
+			       u16 command, u16 data)
+{
+	struct i2c_msg msg;
+	u8 buf[3];
+	int ret;
+
+	// 8-bit/ byte addressable register
+		
+	buf[0] = command & 0xff;
+	data = swab16(data);
+	memcpy(buf + 1, &data,    2);
+
+	msg.addr  = client->addr;
+	msg.flags = 0;
+	msg.len   = 3;
+	msg.buf   = buf;
+		
+	/*
+	 * i2c_transfer return message length,
+	 * but this function should return 0 if correct case
+	 */
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret >= 0)
+		ret = 0;
+
+	return ret;
+}
+
+/**
+ * mt9p031_init_camera - initialize camera settings
+ * @client: pointer to i2c client
+ * Initialize camera settings 
+ */ 
+static int mt9p031_init_camera(const struct i2c_client *client)
+{
+	int ret;
+
+	ret = mt9p031_reg_write(client, REG_MT9P031_RESET, 0x0001);	//High
+	ret |= mt9p031_reg_write(client, REG_MT9P031_RESET, 0x0000);	//Low
+	mdelay(100);
+
+	ret |= mt9p031_reg_write(client, REG_MT9P031_SHUTTER_WIDTH_U, 0x0000);  	//Shutter_width_U
+	ret |= mt9p031_reg_write(client, REG_MT9P031_SHUTTER_WIDTH_L, 0x00E6);  	//shutter_width_L
+	ret |= mt9p031_reg_write(client, REG_MT9P031_SHUTTER_DELAY, 0x0613);  	//shutter_delay_reg
+	ret |= mt9p031_reg_write(client, REG_MT9P031_GREEN_1_GAIN, 0x0051);  	//Green1_gain_reg
+	ret |= mt9p031_reg_write(client, REG_MT9P031_BLUE_GAIN, 0x0058);  	//Blue_gain_reg
+	ret |= mt9p031_reg_write(client, REG_MT9P031_RED_GAIN, 0x0053);  	//Red_gain_reg
+	ret |= mt9p031_reg_write(client, REG_MT9P031_GREEN_2_GAIN, 0x0051);  	//Green2_gain_reg
+	ret |= mt9p031_reg_write(client, REG_MT9P031_READ_MODE1, 0x0006);  	//Read_mode_1 //disable AB
+	ret |= mt9p031_reg_write(client, REG_MT9P031_HBLANK, 0x0600);  	//Horz_blznk_reg = 1536
+	
+	ret |= mt9p031_reg_write(client, REG_MT9P031_PLL_CTRL, 0x0051);  	//PLL_CTRL; power up pll
+	ret |= mt9p031_reg_write(client, REG_MT9P031_PLL_CONF1, 0x1801);		//PLL_CONFIG_1: m=24, n=1
+	ret |= mt9p031_reg_write(client, REG_MT9P031_PLL_CONF2, 0x0002);		//PLL_CONFIG_2: p1=2, p2=0
+	
+	mdelay(10);  										//wait 10 ms for VCO to lock
+	ret |= mt9p031_reg_write(client, REG_MT9P031_PLL_CTRL, 0x0053);		//PLL_CONTROL; use PLL
+	mdelay(200);
+	
+	ret |= mt9p031_reg_write(client, REG_MT9P031_HBLANK, 0x01C2);  	//Horz_blank_reg
+	ret |= mt9p031_reg_write(client, REG_MT9P031_OUT_CTRL, 0x1F8E);		//Enable parll fifo data
+	ret |= mt9p031_reg_write(client, REG_MT9P031_SHUTTER_WIDTH_L, 0x1000);	//Shutter width lower; integration time register
+	
+	return ret>= 0 ? 0 : -EIO;
+}
+
+/**
+ * mt9p031_sublevel_optimization - sublevel optimization
+ * @client: pointer to i2c client
+ */ 
+static int mt9p031_sublevel_optimization(struct i2c_client *client)
+{
+	int ret;
+	
+	ret = mt9p031_reg_write(client, 0x70, 0x5C);	
+	ret |= mt9p031_reg_write(client, 0x71, 0x5B00);
+	ret |= mt9p031_reg_write(client, 0x72, 0x5900);
+	ret |= mt9p031_reg_write(client, 0x73, 0x200);
+	ret |= mt9p031_reg_write(client, 0x74, 0x200);
+	ret |= mt9p031_reg_write(client, 0x75, 0x2800);
+	ret |= mt9p031_reg_write(client, 0x76, 0x3E29);
+	ret |= mt9p031_reg_write(client, 0x77, 0x3E29);
+	ret |= mt9p031_reg_write(client, 0x78, 0x583F);
+	ret |= mt9p031_reg_write(client, 0x79, 0x5B00);
+	ret |= mt9p031_reg_write(client, 0x7a, 0x5A00);
+	ret |= mt9p031_reg_write(client, 0x7b, 0x5900);
+	ret |= mt9p031_reg_write(client, 0x7c, 0x5900);
+	ret |= mt9p031_reg_write(client, 0x7e, 0x5900);
+	ret |= mt9p031_reg_write(client, 0x7f, 0x5900);
+	ret |= mt9p031_reg_write(client, 0x6, 0x0);
+	ret |= mt9p031_reg_write(client, 0x29, 0x481);
+	ret |= mt9p031_reg_write(client, 0x3e, 0x87);
+	ret |= mt9p031_reg_write(client, 0x3f, 0x7);
+	ret |= mt9p031_reg_write(client, 0x41, 0x3);
+	ret |= mt9p031_reg_write(client, 0x48, 0x18);
+	ret |= mt9p031_reg_write(client, 0x5f, 0x1C16);
+	ret |= mt9p031_reg_write(client, 0x57, 0x7);
+	ret |= mt9p031_reg_write(client, 0x2A, 0xFF74);
+	
+	if (ret < 0)
+		ret = 0;
+	
+	return ret;
+}
+
+/**
+ * struct vcontrol - Video controls
+ * @v4l2_queryctrl: V4L2 VIDIOC_QUERYCTRL ioctl structure
+ * @current_value: current value of this control
+ */
+static struct vcontrol {
+	struct v4l2_queryctrl qc;
+	int current_value;
+} mt9p031_video_control[] = {
+	{
+		{
+			.id = V4L2_CID_EXPOSURE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Exposure",
+			.minimum = MT9P031_MIN_EXPOSURE,
+			.maximum = MT9P031_MAX_EXPOSURE,
+			.step = MT9P031_EXPOSURE_STEP,
+			.default_value = MT9P031_DEF_EXPOSURE,
+		},
+		.current_value = MT9P031_DEF_EXPOSURE,
+	},
+	{
+		{
+			.id = V4L2_CID_GAIN,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Analog Gain",
+			.minimum = MT9P031_EV_MIN_GAIN,
+			.maximum = MT9P031_EV_MAX_GAIN,
+			.step = MT9P031_EV_GAIN_STEP,
+			.default_value = MT9P031_EV_DEF_GAIN,
+		},
+		.current_value = MT9P031_EV_DEF_GAIN,
+	},
+};
+
+/**
+ * find_vctrl - Finds the requested ID in the video control structure array
+ * @id: ID of control to search the video control array for
+ *
+ * Returns the index of the requested ID from the control structure array
+ */
+static int
+find_vctrl(int id)
+{
+	int i;
+
+	if (id < V4L2_CID_BASE)
+		return -EDOM;
+
+	for (i = (ARRAY_SIZE(mt9p031_video_control) - 1); i >= 0; i--)
+		if (mt9p031_video_control[i].qc.id == id)
+			break;
+	if (i < 0)
+		i = -EINVAL;
+	return i;
+}
+
+/**
+ * mt9p031_calc_size - Find the best match for a requested image capture size
+ * @width: requested image width in pixels
+ * @height: requested image height in pixels
+ *
+ * Find the best match for a requested image capture size.  The best match
+ * is chosen as the nearest match that has the same number or fewer pixels
+ * as the requested size, or the smallest image size if the requested size
+ * has fewer pixels than the smallest image.
+ */
+static enum mt9p031_image_size mt9p031_calc_size(unsigned int width,
+						 unsigned int height)
+{
+	enum mt9p031_image_size isize;
+	unsigned long pixels = width * height;
+
+	for (isize = VGA_BIN_30FPS; isize <= MT9P031_FIVE_MP; isize++) {
+		if (mt9p031_sizes[isize].height *
+					mt9p031_sizes[isize].width >= pixels) {
+			
+			return isize;
+		}
+	}
+
+	return MT9P031_FIVE_MP;
+}
+
+/**
+ * mt9p031_find_isize - Find the best match for a requested image capture size
+ * @width: requested image width in pixels
+ * @height: requested image height in pixels
+ *
+ * Find the best match for a requested image capture size.  The best match
+ * is chosen as the nearest match that has the same number or fewer pixels
+ * as the requested size, or the smallest image size if the requested size
+ * has fewer pixels than the smallest image.
+ */
+static enum mt9p031_image_size mt9p031_find_isize(unsigned int width)
+{
+	enum mt9p031_image_size isize;
+
+	for (isize = VGA_BIN_30FPS; isize <= MT9P031_FIVE_MP; isize++) {
+		if (mt9p031_sizes[isize].width >= width)
+			break;
+	}
+
+	return isize;
+}
+
+/**
+ * mt9p031_calc_xclk - Calculate the required xclk frequency
+ * @c: i2c client driver structure
+ *
+ * Given the image capture format in pix, the nominal frame period in
+ * timeperframe, calculate and return the required xclk frequency
+ */
+static unsigned long mt9p031_calc_xclk(struct i2c_client *c)
+{
+	struct mt9p031_priv *priv = i2c_get_clientdata(c);
+	struct v4l2_fract *timeperframe = &priv->timeperframe;
+	struct v4l2_pix_format *pix = &priv->pix;
+
+	if (timeperframe->numerator == 0 ||
+	    timeperframe->denominator == 0) {
+		/* supply a default nominal_timeperframe */
+		timeperframe->numerator = 1;
+		timeperframe->denominator = MT9P031_DEF_FPS;
+	}
+
+	priv->fps = timeperframe->denominator / timeperframe->numerator;
+	if (priv->fps < MT9P031_MIN_FPS)
+		priv->fps = MT9P031_MIN_FPS;
+	else if (priv->fps > MT9P031_MAX_FPS)
+		priv->fps = MT9P031_MAX_FPS;
+
+	timeperframe->numerator = 1;
+	timeperframe->denominator = priv->fps;
+
+	if ((pix->width <= VGA_WIDTH) && (priv->fps > 15))
+		return MT9P031_XCLK_NOM_2;
+
+	return MT9P031_XCLK_NOM_1;
+}
+
+/************************************************************************
+			i2c driver
+************************************************************************/
+/**
+ * mt9p031_detect - Detect if an mt9p031 is present, and if so which revision
+ * @client: pointer to the i2c client driver structure
+ *
+ * Returns a negative error number if no device is detected
+ */
+static int mt9p031_detect(struct i2c_client *client)
+{
+	struct mt9p031_priv *priv = i2c_get_clientdata(client);
+	const char	*devname;
+	u16 chipid;
+	
+	if (!client)
+		return -ENODEV;
+	/*
+	 * Set Normal Mode
+	 */
+	if(mt9p031_reg_write(client, REG_MT9P031_OUT_CTRL, MT9P031_NORMAL_OPERATION_MODE))
+		return -ENODEV;
+	/*
+	 * check and show chip ID
+	 */
+	if(mt9p031_reg_read(client, REG_MT9P031_CHIP_VERSION, &chipid)) 
+		return -ENODEV;
+		
+	if(chipid == MT9P031_CHIP_ID) {
+		devname = "mt9p031";
+		priv->model = V4L2_IDENT_MT9P031;
+		DPRINTK_DRIVER("Chip ID Read Successful 0x%x\n", chipid);
+		dev_info(&client->dev, "%s chip ID %04x\n", devname, chipid);
+		return 0;
+	}
+			
+	dev_err(&client->dev, "Product ID error %04x\n", chipid);
+		return -ENODEV;
+}
+
+/**
+ * mt9p031_set_params - sets register settings according to resolution
+ * @client: pointer to standard i2c client
+ * @width: width as queried by ioctl
+ * @height: height as queried by ioctl
+ * @pixelformat: 
+ * finds and sets current format and its settings to corresponding registers
+ */
+static int mt9p031_set_params(struct i2c_client *client, u32 width, u32 height,
+			      u32 pixelformat)
+{
+	struct mt9p031_priv *priv = i2c_get_clientdata(client);
+	int ret;
+	enum mt9p031_image_size i = 0;
+
+	priv->pix.width  = (u16)width;
+	priv->pix.height = (u16)height;
+
+	priv->pix.pixelformat = pixelformat;
+	
+	/*if(width == 640 && height == 480)
+		i = VGA_BIN_30FPS;
+	else if(width == 1280 && height == 720)
+		i = HDV_720P_30FPS;
+	else if(width == 1920 && height == 1080)
+		i = HDV_1080P_30FPS;
+
+	mt9p031_current_format = i;*/
+	i = mt9p031_current_format;
+	
+	priv->pix.width = mt9p031_supported_formats[i].width;
+	priv->pix.height = mt9p031_supported_formats[i].height;
+	
+	ret = mt9p031_reg_write(client, REG_MT9P031_ROWSTART, mt9p031_supported_formats[i].row_start);		//ROW_WINDOW_START_REG
+	ret |= mt9p031_reg_write(client, REG_MT9P031_COLSTART, mt9p031_supported_formats[i].col_start);		//COL_WINDOW_START_REG
+	ret |= mt9p031_reg_write(client, REG_MT9P031_HEIGHT, mt9p031_supported_formats[i].row_size);		//ROW_WINDOW_SIZE_REG=1439
+	ret |= mt9p031_reg_write(client, REG_MT9P031_WIDTH, mt9p031_supported_formats[i].col_size);		//COL_WINDOW_SIZE_REG=2559
+	ret |= mt9p031_reg_write(client, REG_MT9P031_HBLANK, mt9p031_supported_formats[i].hblank);		//HORZ_BLANK=0
+	ret |= mt9p031_reg_write(client, REG_MT9P031_VBLANK, mt9p031_supported_formats[i].vblank);		//VERT_BLANK_REG=720
+	ret |= mt9p031_reg_write(client, REG_MT9P031_SHUTTER_WIDTH_L, 0x0400);		//SHUTTER_WIDTH_LOW (INTEG_TIME_REG = 1024)
+	ret |= mt9p031_reg_write(client, REG_MT9P031_ROW_ADDR_MODE, mt9p031_supported_formats[i].row_addr_mode);		//ROW_MODE, ROW_SKIP=1, ROW_BIN=1	
+	ret |= mt9p031_reg_write(client, REG_MT9P031_COL_ADDR_MODE, mt9p031_supported_formats[i].col_addr_mode);		//COL_MODE, COL_SKIP=1, COL_BIN=1
+	ret |= mt9p031_reg_write(client, REG_MT9P031_READ_MODE2, mt9p031_supported_formats[i].read_mode_2_config);		//READ_MODE_2, COL_SUM
+	ret |= mt9p031_reg_write(client, REG_MT9P031_SHUTTER_WIDTH_U, mt9p031_supported_formats[i].shutter_width_hi);		//SHUTTER_WIDTH_HI
+	ret |= mt9p031_reg_write(client, REG_MT9P031_SHUTTER_WIDTH_L, mt9p031_supported_formats[i].integ_time);		//SHUTTER_WIDTH_LOW (INTEG_TIME_REG)
+	ret |= mt9p031_reg_write(client, REG_MT9P031_SHUTTER_DELAY, mt9p031_supported_formats[i].shutter_delay);		//SHUTTER_DELAY_REG
+	
+	//Sub-Sample optimization
+	ret |= mt9p031_sublevel_optimization(client);
+	
+	return ret;
+}
+
+/**
+ * mt9p031_set_exposure_time - sets exposure time per input value
+ * @exp_time: exposure time to be set on device
+ * @client: pointer to standard i2c client
+ * @lvc: pointer to V4L2 exposure entry in video_controls array
+ *
+ * If the requested exposure time is within the allowed limits, the HW
+ * is configured to use the new exposure time, and the video_controls
+ * array is updated with the new current value.
+ * The function returns 0 upon success.  Otherwise an error code is
+ * returned.
+ */
+static int mt9p031_set_exposure_time(u32 exp_time, struct i2c_client *client,
+								struct vcontrol *lvc)
+{
+	int ret = 0, i, shutter_width, so_p, t_pix_clk, sd_p, shutter_delay;
+	int sw_l ,sw_u ,W ,h_blanking, t_row;
+	
+	if(exp_time < MT9P031_MIN_EXPOSURE)
+			exp_time = MT9P031_MIN_EXPOSURE;
+	else if(exp_time > MT9P031_MAX_EXPOSURE)
+			exp_time = MT9P031_MAX_EXPOSURE;
+	
+	shutter_delay = mt9p031_supported_formats[mt9p031_current_format].shutter_delay;
+	sd_p = min(shutter_delay + 1, 1504);
+	so_p = 208 * (mt9p031_supported_formats[mt9p031_current_format].row_bin + 1) + 98 + sd_p - 94;
+	t_pix_clk = (Q12/96 );	
+	h_blanking = mt9p031_supported_formats[mt9p031_current_format].hblank + 1;
+	W = (mt9p031_supported_formats[mt9p031_current_format].width + 1) / (mt9p031_supported_formats[mt9p031_current_format].row_bin + 1);
+		
+	t_row = 2 * t_pix_clk * max(W/2 + max(h_blanking, hb_min[mt9p031_supported_formats[mt9p031_current_format].row_bin][mt9p031_supported_formats[mt9p031_current_format].col_bin]),
+							  (41 + 346 * (mt9p031_supported_formats[mt9p031_current_format].row_bin + 1) + 99))/Q12;
+							  
+	shutter_width = (exp_time + 2*so_p*t_pix_clk) / t_row;
+	
+	if (shutter_width<  3) {
+		sd_p = 1232 >  shutter_delay ? 1232 : shutter_delay;
+		so_p = 208 * (mt9p031_supported_formats[mt9p031_current_format].row_bin + 1) + 98 + sd_p - 94;
+		shutter_width = ((exp_time*Q12 + 2*so_p*t_pix_clk) / (t_row * Q12));	
+	}
+	
+	if (shutter_width <  1)
+		shutter_width = 1;
+	sw_l = shutter_width&  0xffff;
+	sw_u = (shutter_width)>>  16;
+	ret = mt9p031_reg_write(client, REG_MT9P031_SHUTTER_WIDTH_L,sw_l);
+	mdelay(1);
+	ret = mt9p031_reg_write(client, REG_MT9P031_SHUTTER_WIDTH_U,sw_u);
+	
+	if (ret)
+		dev_err(&client->dev, "Error setting exposure time %d\n",
+									ret);
+	else{										
+		i = find_vctrl(V4L2_CID_EXPOSURE);
+		if (i >= 0) {
+			lvc = &mt9p031_video_control[i];
+			lvc->current_value = exp_time;
+		}
+	}
+	
+	return ret;	
+}
+
+/**
+ * mt9p031_set_gain - sets sensor analog gain per input value
+ * @lineargain: analog gain value index to be set on device
+ * @client: pointer to standard i2c client
+ * @lvc: pointer to V4L2 analog gain entry in video_controls array
+ *
+ * If the requested analog gain is within the allowed limits, the HW
+ * is configured to use the new gain value, and the video_controls
+ * array is updated with the new current value.
+ * The function returns 0 upon success.  Otherwise an error code is
+ * returned.
+ */
+int mt9p031_set_gain(u16 lineargain, struct i2c_client *client,
+							struct vcontrol *lvc)
+{
+	int ret= 0, i;
+	u16 reg_gain = 0;
+		
+	if (lineargain < MT9P031_EV_MIN_GAIN) {
+		lineargain = MT9P031_EV_MIN_GAIN;
+		v4l_err(client, "Gain out of legal range.");
+	}
+	if (lineargain > MT9P031_EV_MAX_GAIN) {
+		lineargain = MT9P031_EV_MAX_GAIN;
+		v4l_err(client, "Gain out of legal range.");
+	}
+
+	reg_gain = MT9P031_EV_GAIN_TBL[lineargain];
+	ret = mt9p031_reg_write(client, REG_MT9P031_GLOBAL_GAIN,
+					reg_gain);
+	
+	if (ret) {
+		dev_err(&client->dev, "Error setting gain.%d", ret);
+		return ret;	
+	}
+	else {
+		i = find_vctrl(V4L2_CID_GAIN);
+		if (i >= 0) {
+			lvc = &mt9p031_video_control[i];
+			lvc->current_value = lineargain;
+		}
+	}
+
+	return ret;
+}
+
+/************************************************************************
+			v4l2_ioctls
+************************************************************************/
+/**
+ * mt9p031_v4l2_int_s_parm - V4L2 sensor interface handler for VIDIOC_S_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_S_PARM ioctl structure
+ *
+ * Configures the sensor to use the input parameters, if possible.  If
+ * not possible, reverts to the old parameters and returns the
+ * appropriate error code.
+ */
+
+
+static int mt9p031_v4l2_int_s_parm(struct v4l2_int_device *s,
+				   struct v4l2_streamparm *a)
+{
+	struct mt9p031_priv *priv = s->priv;
+	struct i2c_client *client = priv->client;
+	struct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;
+
+	priv->timeperframe = *timeperframe;
+	priv->xclk_current = mt9p031_calc_xclk(client);
+	*timeperframe = priv->timeperframe;
+
+	return 0;
+}
+
+/**
+ * mt9p031_v4l2_int_g_parm - V4L2 sensor interface handler for VIDIOC_G_PARM ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @a: pointer to standard V4L2 VIDIOC_G_PARM ioctl structure
+ *
+ * Returns the sensor's video CAPTURE parameters.
+ */
+static int mt9p031_v4l2_int_g_parm(struct v4l2_int_device *s,
+				   struct v4l2_streamparm *a)
+{
+	struct v4l2_captureparm *cparm = &a->parm.capture;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(a, 0, sizeof(*a));
+	a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	cparm->capability = V4L2_CAP_TIMEPERFRAME;
+	cparm->timeperframe.numerator = 1;
+	cparm->timeperframe.denominator = 30;
+
+	return 0;
+}
+
+/**
+ * mt9p031_v4l2_int_s_power - V4L2 sensor interface handler for vidioc_int_s_power_num
+ * @s: pointer to standard V4L2 device structure
+ * @on: power state to which device is to be set
+ *
+ * Sets devices power state to requrested state, if possible.
+ */
+static int mt9p031_v4l2_int_s_power(struct v4l2_int_device *s,
+				    enum v4l2_power power)
+{
+	struct mt9p031_priv *priv = s->priv;
+	struct i2c_client *client = priv->client;
+	
+	int ret;
+
+	switch (power) {
+	case V4L2_POWER_STANDBY:
+		/* FALLTHROUGH */
+	case V4L2_POWER_OFF:
+		ret = priv->pdata->power_set(s, power);
+		if (ret < 0) {
+			dev_err(&client->dev, "Unable to set target board power "
+					 "state (OFF/STANDBY)\n");
+			return ret;
+		}
+		break;
+	case V4L2_POWER_ON:
+		ret = priv->pdata->power_set(s, power);
+
+		if (ret < 0) {
+			dev_err(&client->dev, "Unable to set target board power "
+					 "state (ON)\n");
+			return ret;
+		}
+		if (!(priv->flags & INIT_DONE)) {
+			ret = mt9p031_detect(client);
+			if (ret < 0) {
+				dev_err(&client->dev, "Unable to detect sensor\n");
+				return ret;
+			}
+			priv->flags |= INIT_DONE;
+		}
+
+		ret = mt9p031_init_camera(client);
+		if (ret < 0) {
+				dev_err(&client->dev, "Unable to initialize sensor\n");
+				return ret;
+		}
+	}
+	
+	return 0;
+}
+
+/**
+ * mt9p031_v4l2_g_ctrl - V4L2 sensor interface handler for VIDIOC_G_CTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @vc: standard V4L2 VIDIOC_G_CTRL ioctl structure
+ *
+ * If the requested control is supported, returns the control's current
+ * value from the video_control[] array.  Otherwise, returns -EINVAL
+ * if the control is not supported.
+ */
+static int mt9p031_v4l2_g_ctrl(struct v4l2_int_device *s,
+			     struct v4l2_control *vc)
+{
+	struct vcontrol *lvc;
+	int i;
+
+	i = find_vctrl(vc->id);
+	if (i < 0)
+		return -EINVAL;
+	lvc = &mt9p031_video_control[i];
+
+	switch (vc->id) {
+	case  V4L2_CID_EXPOSURE:
+		vc->value = lvc->current_value;
+		break;
+	case V4L2_CID_GAIN:
+		vc->value = lvc->current_value;
+		break;
+	}
+
+	return 0;
+}
+
+/**
+ * mt9p031_v4l2_s_ctrl - V4L2 sensor interface handler for VIDIOC_S_CTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @vc: standard V4L2 VIDIOC_S_CTRL ioctl structure
+ *
+ * If the requested control is supported, sets the control's current
+ * value in HW (and updates the video_control[] array).  Otherwise,
+ * returns -EINVAL if the control is not supported.
+ */
+static int mt9p031_v4l2_s_ctrl(struct v4l2_int_device *s,
+			     struct v4l2_control *vc)
+{
+	int retval = -EINVAL;
+	int i;
+	struct vcontrol *lvc;
+	struct mt9p031_priv *priv = s->priv;
+	struct i2c_client *client = priv->client;
+	
+	i = find_vctrl(vc->id);
+	if (i < 0)
+		return -EINVAL;
+	lvc = &mt9p031_video_control[i];
+
+	switch (vc->id) {
+	case V4L2_CID_EXPOSURE:
+		retval = mt9p031_set_exposure_time(vc->value, client, lvc);
+		break;
+	case V4L2_CID_GAIN:
+		retval = mt9p031_set_gain(vc->value, client, lvc);
+		break;
+	}
+
+	return retval;
+}
+
+/**
+ * mt9p031_v4l2_queryctrl - V4L2 sensor interface handler for VIDIOC_QUERYCTRL ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @qc: standard V4L2 VIDIOC_QUERYCTRL ioctl structure
+ *
+ * If the requested control is supported, returns the control information
+ * from the video_control[] array.  Otherwise, returns -EINVAL if the
+ * control is not supported.
+ */
+static int mt9p031_v4l2_queryctrl(struct v4l2_int_device *s, struct v4l2_queryctrl *qc)
+{
+	int i;
+
+	i = find_vctrl(qc->id);
+	if (i == -EINVAL)
+		qc->flags = V4L2_CTRL_FLAG_DISABLED;
+
+	if (i < 0)
+		return -EINVAL;
+
+	*qc = mt9p031_video_control[i].qc;
+	return 0;
+}
+
+/**
+ * mt9p031_v4l2_int_g_priv - V4L2 sensor interface handler for vidioc_int_g_priv_num
+ * @s: pointer to standard V4L2 device structure
+ * @p: void pointer to hold sensor's private data address
+ *
+ * Returns device's (sensor's) private data area address in p parameter
+ */
+static int mt9p031_v4l2_int_g_priv(struct v4l2_int_device *s, void *p)
+{
+	struct mt9p031_priv *priv = s->priv;
+
+	return priv->pdata->priv_data_set(p);
+}
+
+/**
+ * mt9p031_v4l2_int_g_ifparm - V4L2 sensor interface handler for vidioc_int_g_priv_num
+ * @s: pointer to standard V4L2 device structure
+ * @p: void pointer to hold sensor's ifparm
+ *
+ * Returns device's (sensor's) ifparm in p parameter
+ */
+static int mt9p031_v4l2_int_g_ifparm(struct v4l2_int_device *s,
+				     struct v4l2_ifparm *p)
+{
+	struct mt9p031_priv *priv = s->priv;
+	int rval;
+
+	if (p == NULL)
+		return -EINVAL;
+
+	if (!priv->pdata->ifparm)
+		return -EINVAL;
+
+	rval = priv->pdata->ifparm(p);
+	if (rval) {
+		v4l_err(priv->client, "g_ifparm.Err[%d]\n", rval);
+		return rval;
+	}
+
+	return 0;
+}
+
+/**
+ * imt9p031_v4l2_int_try_fmt_cap - Implement the CAPTURE buffer VIDIOC_TRY_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 VIDIOC_TRY_FMT ioctl structure
+ *
+ * Implement the VIDIOC_TRY_FMT ioctl for the CAPTURE buffer type.  This
+ * ioctl is used to negotiate the image capture size and pixel format
+ * without actually making it take effect.
+ */
+static int mt9p031_v4l2_int_try_fmt_cap(struct v4l2_int_device *s,
+					struct v4l2_format *f)
+{
+	enum mt9p031_image_size isize;
+	int ifmt;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	struct mt9p031_priv *priv = s->priv;
+	struct v4l2_pix_format *pix2 = &priv->pix;
+
+	isize = mt9p031_calc_size(pix->width, pix->height);
+	mt9p031_current_format = isize;
+	
+	pix->width = mt9p031_sizes[isize].width;
+	pix->height = mt9p031_sizes[isize].height;
+	for (ifmt = 0; ifmt < mt9p031_num_formats; ifmt++) {
+		if (pix->pixelformat == mt9p031_formats[ifmt].pixelformat)
+			break;
+	}
+	if (ifmt == mt9p031_num_formats)
+		ifmt = 0;
+	pix->pixelformat = mt9p031_formats[ifmt].pixelformat;
+	pix->field = V4L2_FIELD_NONE;
+	pix->bytesperline = pix->width * 2;
+	pix->sizeimage = pix->bytesperline * pix->height;
+	pix->priv = 0;
+	pix->colorspace = V4L2_COLORSPACE_SRGB;
+	
+	*pix2 = *pix;
+	return 0;
+/*	
+	f->fmt.pix.width = mt9p031_supported_formats[mt9p031_current_format].width;
+	f->fmt.pix.height = mt9p031_supported_formats[mt9p031_current_format].height;
+	f->fmt.pix.field = V4L2_FIELD_NONE;
+	f->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;
+
+	return 0;*/
+}
+
+/**
+ * mt9p031_v4l2_int_s_fmt_cap - V4L2 sensor interface handler for VIDIOC_S_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 VIDIOC_S_FMT ioctl structure
+ *
+ * If the requested format is supported, configures the HW to use that
+ * format, returns error code if format not supported or HW can't be
+ * correctly configured.
+ */
+static int mt9p031_v4l2_int_s_fmt_cap(struct v4l2_int_device *s,
+				      struct v4l2_format *f)
+{
+	struct mt9p031_priv *priv = s->priv;
+	struct i2c_client *client = priv->client;
+
+	mt9p031_v4l2_int_try_fmt_cap(s, f);
+	return mt9p031_set_params(client, f->fmt.pix.width, f->fmt.pix.height,
+				  f->fmt.pix.pixelformat);
+}
+
+/**
+ * mt9p031_v4l2_int_enum_framesizes - V4L2 sensor if handler for vidioc_int_enum_framesizes
+ * @s: pointer to standard V4L2 device structure
+ * @frms: pointer to standard V4L2 framesizes enumeration structure
+ *
+ * Returns possible framesizes depending on choosen pixel format
+ */
+static int mt9p031_v4l2_int_enum_framesizes(struct v4l2_int_device *s,
+					    struct v4l2_frmsizeenum *frms)
+{
+	int ifmt;
+
+	for (ifmt = 0; ifmt < ARRAY_SIZE(mt9p031_formats); ifmt++)
+		if (mt9p031_formats[ifmt].pixelformat == frms->pixel_format)
+			break;
+
+	if (ifmt == ARRAY_SIZE(mt9p031_formats))
+		return -EINVAL;
+
+	/* Do we already reached all discrete framesizes? */
+	if (frms->index >= ARRAY_SIZE(mt9p031_sizes))
+		return -EINVAL;
+
+	frms->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	frms->discrete.width = mt9p031_sizes[frms->index].width;
+	frms->discrete.height = mt9p031_sizes[frms->index].height;
+
+	return 0;
+
+}
+
+/**
+ * ioctl_enum_fmt_cap - Implement the CAPTURE buffer VIDIOC_ENUM_FMT ioctl
+ * @s: pointer to standard V4L2 device structure
+ * @fmt: standard V4L2 VIDIOC_ENUM_FMT ioctl structure
+ *
+ * Implement the VIDIOC_ENUM_FMT ioctl for the CAPTURE buffer type.
+ */
+static int mt9p031_v4l2_int_enum_fmt_cap(struct v4l2_int_device *s,
+					 struct v4l2_fmtdesc *fmt)
+{
+	int index = fmt->index;
+	enum v4l2_buf_type type = fmt->type;
+
+	memset(fmt, 0, sizeof(*fmt));
+	fmt->index = index;
+	fmt->type = type;
+
+	switch (fmt->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		if (index >= ARRAY_SIZE(mt9p031_formats))
+			return -EINVAL;
+	        break;
+	default:
+		return -EINVAL;
+	}
+
+	strlcpy(fmt->description, mt9p031_formats[index].description,
+					sizeof(fmt->description));
+	fmt->pixelformat = mt9p031_formats[index].pixelformat;
+
+	return 0;
+}
+
+/**
+ * mt9p031_v4l2_int_g_fmt_cap - V4L2 sensor interface handler for ioctl_g_fmt_cap
+ * @s: pointer to standard V4L2 device structure
+ * @f: pointer to standard V4L2 v4l2_format structure
+ *
+ * Returns the sensor's current pixel format in the v4l2_format
+ * parameter.
+ */
+static int mt9p031_v4l2_int_g_fmt_cap(struct v4l2_int_device *s,
+				      struct v4l2_format *f)
+{
+	struct mt9p031_priv *priv = s->priv;
+	
+	f->fmt.pix.width	= priv->pix.width;
+	f->fmt.pix.height	= priv->pix.height;
+	f->fmt.pix.pixelformat	= V4L2_COLORSPACE_SRGB;
+	f->fmt.pix.pixelformat	= priv->pix.pixelformat;
+	f->fmt.pix.field	= V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int mt9p031_v4l2_int_enum_frameintervals(struct v4l2_int_device *s,
+						struct v4l2_frmivalenum *frmi)
+{
+	int ifmt;
+	int max_size;
+
+	for (ifmt = 0; ifmt < ARRAY_SIZE(mt9p031_formats); ifmt++)
+		if (mt9p031_formats[ifmt].pixelformat == frmi->pixel_format)
+			break;
+
+	if (ifmt == ARRAY_SIZE(mt9p031_formats))
+		return -EINVAL;
+
+	/* Do we already reached all discrete framesizes? */
+	max_size = ARRAY_SIZE(mt9p031_sizes);
+	if (((frmi->width == mt9p031_sizes[max_size-1].width) &&
+				(frmi->height == mt9p031_sizes[max_size-1].height)) ||
+				((frmi->width == mt9p031_sizes[max_size-2].width) &&
+				(frmi->height == mt9p031_sizes[max_size-2].height))) {
+		/* FIXME: The only frameinterval supported by 5MP and 3MP
+		 * capture sizes is 1/10 fps
+		 */
+		if (frmi->index != 0)
+			return -EINVAL;
+	} else {
+		if (frmi->index >= ARRAY_SIZE(mt9p031_frameintervals))
+			return -EINVAL;
+	}
+
+	frmi->type = V4L2_FRMSIZE_TYPE_DISCRETE;
+	frmi->discrete.numerator =
+				mt9p031_frameintervals[frmi->index].numerator;
+	frmi->discrete.denominator =
+				mt9p031_frameintervals[frmi->index].denominator;
+	
+	return 0;
+}
+
+static struct v4l2_int_ioctl_desc mt9p031_ioctl_desc[] = {
+	{ .num = vidioc_int_enum_framesizes_num,
+	  .func = (v4l2_int_ioctl_func *)mt9p031_v4l2_int_enum_framesizes },
+	{ .num = vidioc_int_enum_frameintervals_num,
+	  .func = (v4l2_int_ioctl_func *)mt9p031_v4l2_int_enum_frameintervals },
+	{ .num = vidioc_int_s_power_num,
+	  .func = (v4l2_int_ioctl_func *)mt9p031_v4l2_int_s_power },
+	{ .num = vidioc_int_g_priv_num,
+	  .func = (v4l2_int_ioctl_func *)mt9p031_v4l2_int_g_priv },
+	{ .num = vidioc_int_g_ifparm_num,
+	  .func = (v4l2_int_ioctl_func *)mt9p031_v4l2_int_g_ifparm },
+	{ .num = vidioc_int_enum_fmt_cap_num,
+	  .func = (v4l2_int_ioctl_func *)mt9p031_v4l2_int_enum_fmt_cap },
+	{ .num = vidioc_int_try_fmt_cap_num,
+	  .func = (v4l2_int_ioctl_func *)mt9p031_v4l2_int_try_fmt_cap },
+	{ .num = vidioc_int_g_fmt_cap_num,
+	  .func = (v4l2_int_ioctl_func *)mt9p031_v4l2_int_g_fmt_cap }, 
+	{ .num = vidioc_int_s_fmt_cap_num,
+	  .func = (v4l2_int_ioctl_func *)mt9p031_v4l2_int_s_fmt_cap },
+	{ .num = vidioc_int_g_parm_num,
+	  .func = (v4l2_int_ioctl_func *)mt9p031_v4l2_int_g_parm },
+	{ .num = vidioc_int_s_parm_num,
+	  .func = (v4l2_int_ioctl_func *)mt9p031_v4l2_int_s_parm },
+	{ .num = vidioc_int_g_ctrl_num,
+	  .func = (v4l2_int_ioctl_func *)mt9p031_v4l2_g_ctrl },
+	{ .num = vidioc_int_s_ctrl_num,
+	  .func = (v4l2_int_ioctl_func *)mt9p031_v4l2_s_ctrl },
+	{ .num = vidioc_int_queryctrl_num,
+	  .func = (v4l2_int_ioctl_func *)mt9p031_v4l2_queryctrl },
+};
+
+#ifdef MT9P031_DEBUG
+/**
+ * ---------------------------------------------------------------------------------
+ * Sysfs
+ * ---------------------------------------------------------------------------------
+ */
+
+/* Basic register read write support */
+static u16 mt9p031_attr_basic_addr  = 0x0000;
+
+static ssize_t
+mt9p031_basic_reg_addr_show( struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "0x%x\n", mt9p031_attr_basic_addr);
+}
+
+static ssize_t
+mt9p031_basic_reg_addr_store( struct device *dev, struct device_attribute *attr, const char *buf, size_t n)
+{
+	u16 val;
+	sscanf(buf, "%x", &val);
+	mt9p031_attr_basic_addr = (u16) val;
+	return n;
+}
+
+static DEVICE_ATTR( basic_reg_addr, S_IRUGO|S_IWUSR, mt9p031_basic_reg_addr_show, mt9p031_basic_reg_addr_store);
+
+
+static ssize_t
+mt9p031_basic_reg_val_show( struct device *dev, struct device_attribute *attr, char *buf)
+{
+	u16 val;
+	int ret;
+	ret = mt9p031_reg_read(sysPriv.client, mt9p031_attr_basic_addr, &val);
+	if(ret < 0){        
+		printk(KERN_INFO "mt9p031: Basic register read failed");
+		return 0; // nothing processed
+	} else {
+		return sprintf(buf, "0x%x\n", val);
+	}
+}
+
+static ssize_t
+mt9p031_basic_reg_val_store( struct device *dev, struct device_attribute *attr, const char *buf, size_t n)
+{
+	u32 val;
+	sscanf(buf, "%x", &val);
+
+	if (mt9p031_reg_write(sysPriv.client, mt9p031_attr_basic_addr, (u16)val)) {
+		printk(KERN_INFO "mt9p031: Basic regiser write failed");
+		return 0; // nothing processed
+	} else {
+		return n;
+	}
+}
+static DEVICE_ATTR( basic_reg_val, S_IRUGO|S_IWUSR, mt9p031_basic_reg_val_show, mt9p031_basic_reg_val_store);
+
+
+/* Exposure time access support */
+static ssize_t
+mt9p031_exposure_val_show( struct device *dev, struct device_attribute *attr, char *buf)
+{
+	u32 val;
+	struct vcontrol *lvc;
+	int i = find_vctrl(V4L2_CID_EXPOSURE);
+	if (i < 0)
+		return -EINVAL;
+	lvc = &mt9p031_video_control[i];
+	val = lvc->current_value;
+	
+	if(val < 0){        
+		printk(KERN_INFO "mt9p031: Exposure value read failed");
+		return 1; // nothing processed
+	} else {
+		return sprintf(buf, "%d\n", val);
+	}
+}
+
+
+static ssize_t
+mt9p031_exposure_val_store( struct device *dev, struct device_attribute *attr, const char *buf, size_t n)
+{
+	u32 val;
+	struct i2c_client *client;
+	struct vcontrol *lvc;
+	
+	sscanf(buf, "%d", &val);
+	client = sysPriv.client;
+		
+	lvc = &mt9p031_video_control[V4L2_CID_EXPOSURE];	
+
+	if (mt9p031_set_exposure_time((u32)val, client, lvc)) {
+		printk(KERN_INFO "mt9p031: Exposure write failed");
+		return n; // nothing processed
+	} else {
+		return n;
+    }
+}
+
+static DEVICE_ATTR( exposure_val, S_IRUGO|S_IWUSR, mt9p031_exposure_val_show, mt9p031_exposure_val_store);
+
+
+/* Global Gain access support */
+static ssize_t
+mt9p031_gain_val_show( struct device *dev, struct device_attribute *attr, char *buf)
+{
+	u16 val;
+	struct vcontrol *lvc;
+    
+	int i = find_vctrl(V4L2_CID_GAIN);
+	if (i < 0)
+		return -EINVAL;
+	lvc = &mt9p031_video_control[i];
+	val = lvc->current_value;
+      
+	if(val < 0){        
+		printk(KERN_INFO "mt9p031: Global Gain value read failed");
+		return 1; // nothing processed
+	} else {
+		return sprintf(buf, "%d\n", val);
+    }
+}
+
+static ssize_t
+mt9p031_gain_val_store( struct device *dev, struct device_attribute *attr, const char *buf, size_t n)
+{
+	u16 val;
+	struct i2c_client *client;
+	struct vcontrol *lvc;
+	
+	sscanf(buf, "%d", &val);
+	client = sysPriv.client;
+		
+	lvc = &mt9p031_video_control[V4L2_CID_GAIN];	
+		
+	if (mt9p031_set_gain(val, client, lvc)) {
+		printk(KERN_INFO "mt9p031: Global gain write failed");
+		return n; // nothing processed
+	} else {
+		return n;
+	}
+}
+
+static DEVICE_ATTR( gain_val, S_IRUGO|S_IWUSR, mt9p031_gain_val_show, mt9p031_gain_val_store);
+
+
+static struct attribute *mt9p031_sysfs_attr[] = {
+	&dev_attr_basic_reg_addr.attr,
+	&dev_attr_basic_reg_val.attr,
+	&dev_attr_exposure_val.attr,
+	&dev_attr_gain_val.attr,
+};
+
+static int mt9p031_sysfs_add(struct kobject *kobj)
+{
+	int i = ARRAY_SIZE(mt9p031_sysfs_attr);
+	int rval = 0;
+	
+	do {
+		rval = sysfs_create_file(kobj, mt9p031_sysfs_attr[--i]);
+	} while((i > 0) && (rval == 0));
+	return rval;
+}
+
+static int mt9p031_sysfs_rm(struct kobject *kobj)
+{
+	int i = ARRAY_SIZE(mt9p031_sysfs_attr);
+	int rval = 0;
+
+	do {
+		sysfs_remove_file(kobj, mt9p031_sysfs_attr[--i]);
+	} while(i > 0);
+	return rval;
+}
+#endif	//MT9P031_DEBUG
+
+static struct v4l2_int_slave mt9p031_slave = {
+	.ioctls = mt9p031_ioctl_desc,
+	.num_ioctls = ARRAY_SIZE(mt9p031_ioctl_desc),
+};
+
+static int mt9p031_probe(struct i2c_client *client,
+			 const struct i2c_device_id *did)
+{
+	struct mt9p031_priv *priv;
+	struct v4l2_int_device *v4l2_int_device;
+	int ret;
+	if (!client->dev.platform_data) {
+		dev_err(&client->dev, "no platform data?\n");
+		return -ENODEV;
+	}
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_int_device = kzalloc(sizeof(*v4l2_int_device), GFP_KERNEL);
+	if (!v4l2_int_device) {
+		kfree(priv);
+		return -ENOMEM;
+	}
+
+#ifdef MT9P031_HEADBOARD
+	mt9p031_config_PCA9543A(client);		//configure i2c level shifter on mt9p031 head-board, no need for Leopard module
+	mdelay(10);
+#endif	//MT9P031_HEADBOARD
+	
+	v4l2_int_device->module = THIS_MODULE;
+	strncpy(v4l2_int_device->name, "mt9p031", sizeof(v4l2_int_device->name));
+	
+	v4l2_int_device->type = v4l2_int_type_slave;
+	v4l2_int_device->u.slave = &mt9p031_slave;
+
+	v4l2_int_device->priv = priv;
+
+	priv->v4l2_int_device = v4l2_int_device;
+	priv->client = client;
+	priv->pdata = client->dev.platform_data;
+	
+	priv->pdata->flags = MT9P031_FLAG_PCLK_RISING_EDGE;
+	i2c_set_clientdata(client, priv);
+
+	/* Setting Pixel Values */
+	priv->pix.width       = mt9p031_sizes[0].width;
+	priv->pix.height      = mt9p031_sizes[0].height;
+	priv->pix.pixelformat = mt9p031_formats[0].pixelformat;
+	
+	sysPriv.client = priv->client;
+
+	ret = v4l2_int_device_register(priv->v4l2_int_device);
+	if (ret) {
+		i2c_set_clientdata(client, NULL);
+		kfree(v4l2_int_device);
+		kfree(priv);
+	}
+	
+#ifdef MT9P031_DEBUG
+	mt9p031_sysfs_add(&client->dev.kobj);
+#endif	//MT9P031_DEBUG	
+	return ret;
+}
+
+static int mt9p031_remove(struct i2c_client *client)
+{
+	struct mt9p031_priv *priv = i2c_get_clientdata(client);
+
+	v4l2_int_device_unregister(priv->v4l2_int_device);
+	i2c_set_clientdata(client, NULL);
+	mt9p031_sysfs_rm(&client->dev.kobj);
+	
+	kfree(priv->v4l2_int_device);
+	kfree(priv);
+	return 0;
+}
+
+static const struct i2c_device_id mt9p031_id[] = {
+	{ "mt9p031", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, mt9p031_id);
+
+static struct i2c_driver mt9p031_i2c_driver = {
+	.driver = {
+		.name = "mt9p031",
+	},
+	.probe    = mt9p031_probe,
+	.remove   = mt9p031_remove,
+	.id_table = mt9p031_id,
+};
+
+/************************************************************************
+			module function
+************************************************************************/
+static int __init mt9p031_module_init(void)
+{
+	return i2c_add_driver(&mt9p031_i2c_driver);
+}
+
+static void __exit mt9p031_module_exit(void)
+{
+	i2c_del_driver(&mt9p031_i2c_driver);
+}
+
+module_init(mt9p031_module_init);
+module_exit(mt9p031_module_exit);
+
+MODULE_DESCRIPTION("mt9p031 sensor driver");
+MODULE_AUTHOR("Aptina");
+MODULE_LICENSE("GPL v2");
+
diff -Naur kernel/drivers/media/video/mt9p031.h kernel.tmp/drivers/media/video/mt9p031.h
--- kernel/drivers/media/video/mt9p031.h	1969-12-31 16:00:00.000000000 -0800
+++ kernel.tmp/drivers/media/video/mt9p031.h	2011-04-15 13:09:40.002457552 -0700
@@ -0,0 +1,30 @@
+/* mt9p031 Camera
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __MT9P031_H__
+#define __MT9P031_H__
+
+#include <media/v4l2-int-device.h>
+
+#define MT9P031_I2C_ADDR		0x48 //(0x90 >> 1)
+
+#define MT9P031_CLK_MAX			(27000000) /* 27MHz */
+#define MT9P031_CLK_MIN			(6000000)  /* 6Mhz */
+
+#define MT9P031_FLAG_PCLK_RISING_EDGE	(1 << 0)
+#define MT9P031_FLAG_DATAWIDTH_8	(1 << 1) /* default width is 10 */
+
+struct mt9p031_platform_data {
+	char *master;
+	int (*power_set) (struct v4l2_int_device *s, enum v4l2_power on);
+	int (*ifparm) (struct v4l2_ifparm *p);
+	int (*priv_data_set) (void *);
+	u32 (*set_xclk) (struct v4l2_int_device *s, u32 xclkfreq);
+	u32 flags;
+};
+
+#endif /* __MT9P031_H__ */
